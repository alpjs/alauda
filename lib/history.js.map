{"version":3,"sources":["../src/history.js"],"names":[],"mappings":"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","file":"history.js","sourcesContent":["import { basePath } from './index';\nimport EventEmitter from 'events';\n\nlet eventEmitter = new EventEmitter();\n\nexport function on(event, listener) {\n    return eventEmitter.on(event, listener);\n}\n\nexport function emit(...args) {\n    return eventEmitter.emit(...args);\n}\n\nlet started = false;\n\n// Cached regex for stripping a leading hash/slash and trailing space.\nlet routeStripper = /^[#\\/]|\\s+$/g;\n\nlet _hasPushState = Boolean(window.history && window.history.pushState);\nlet usePushState;\n\nconst _getHash = function (windowOverride) {\n    let match = (windowOverride || window).location.href.match(/#\\/(.*)$/);\n    return match ? match[1] : '';\n};\n\nconst _cleanFragment = function (fragment) {\n    fragment = fragment.replace(routeStripper, '');\n    if ((`/${fragment}/`).startsWith(basePath)) {\n        fragment = fragment.substr(basePath.replace(routeStripper, '').length);\n    }\n    return fragment;\n};\n\nconst _updateHash = function (location, fragment, replace) {\n    if (replace) {\n        location.replace(`${location.toString().replace(/(javascript:|#).*$/, '')}#/${fragment}`);\n    } else {\n        location.hash = `/${fragment}`;\n    }\n};\n\nlet _checkUrlInterval; // eslint-disable-line no-unused-vars\nlet _currentFragment;\nlet _updateBrowserHistory;\n\nexport let getFragment;\n\nexport function start(forceUseHash) {\n    if (started) {\n        throw new Error(/* #if DEV */'history has already been started'/* #/if */);\n    }\n    started = true;\n    usePushState = !forceUseHash && _hasPushState;\n\n    if (usePushState) {\n        getFragment = function () {\n            let fragment = window.location.pathname;\n            let search = window.location.search;\n            if (search) {\n                fragment += search;\n            }\n            return _cleanFragment(fragment);\n        };\n\n        _updateBrowserHistory = (fragment, replace) => {\n            window.history[replace ? 'replaceState' : 'pushState'](\n                {},\n                document.title,\n                `${window.location.protocol}//${window.location.host}${basePath}${fragment}`\n            );\n        };\n    } else {\n        getFragment = function () {\n            let fragment = _getHash();\n            return _cleanFragment(fragment);\n        };\n\n        _updateBrowserHistory = (fragment, replace) => {\n            _updateHash(window.location, fragment, replace);\n        };\n    }\n\n    let fragment = getFragment();\n\n    // Depending on whether we're using pushState or hashes, and whether\n    // 'onhashchange' is supported, determine how we check the URL state.\n    if (usePushState) {\n        window.addEventListener('popstate', checkUrl);\n    } else if ('onhashchange' in window) {\n        window.addEventListener('hashchange', checkUrl);\n    } else {\n        _checkUrlInterval = setInterval(checkUrl, 50);\n    }\n\n    // Determine if we need to change the base url, for a pushState link\n    // opened by a non-pushState browser.\n    _currentFragment = fragment;\n    let loc = window.location;\n\n    // If we've started out with a hash-based route, but we're currently\n    // in a browser where it could be `pushState`-based instead...\n    if (usePushState && loc.hash && loc.pathname === '/') {\n        _currentFragment = _getHash().replace(routeStripper, '');\n        loc.hash = '';\n        window.history.replaceState(\n            { fragment: _currentFragment },\n            document.title,\n            `${loc.protocol}//${loc.host}${basePath}${_currentFragment}`\n        );\n        return false;\n    }\n    return usePushState || fragment === '';\n}\n\n// Checks the current URL to see if it has changed, and if it has, calls `loadUrl`\nexport function checkUrl() {\n    let current = getFragment();\n    if (current === _currentFragment) {\n        return false;\n    }\n\n    loadUrl();\n}\n\n// Attempt to load the current URL fragment.\nexport function loadUrl() {\n    _currentFragment = getFragment();\n    let fragment = basePath + _currentFragment;\n    if (fragment) {\n        let a = document.querySelector(`a[href=\"${fragment}\"]`);\n        if (a) {\n            a.click();\n        } else {\n            if (eventEmitter.emit('load', fragment) === false) {\n                throw new Error('Missing listener for load event');\n            }\n        }\n    }\n}\n\nexport function navigate(fragment, replace) {\n    fragment = (fragment || '');\n    fragment = _cleanFragment(fragment);\n\n    if (fragment.charAt(0) === '?') {\n        fragment = window.location.pathname + fragment;\n        fragment = _cleanFragment(fragment);\n    }\n\n    if (_currentFragment == fragment) {\n        return false;\n    }\n\n    eventEmitter.emit('changed', fragment);\n\n    _currentFragment = fragment;\n    _updateBrowserHistory(fragment, replace);\n}\n"]}